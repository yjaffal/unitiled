#if (UNITY_EDITOR)
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

/// <summary>
/// Maps a 2D tile from tmx file to a 3D model from the atlas
/// provided as prefab by matching the names of tiles and
/// 3D models used to generate these tiles. This script runs
/// in edit mode and can also be invoked in play mode through
/// RealTimeMapReader
/// </summary>

[System.Serializable]
public class TileModelMapper
{
    /// <summary>
    /// Prefabs that have 3D models as children. These are the ones
    /// generated by TileCreator script
    /// </summary>
    private List<Transform> modelsAtlases;

    /// <summary>
    /// A list of SpriteToModel mappings defined so far
    /// </summary>
    private List<SpriteToModel> mappings;

    /// <summary>
    /// The size of each 3D tile (model)
    /// </summary>
    public Vector3 tileScale = Vector3.one;

    /// <summary>
    /// Reference to the attached TMXImporter
    /// </summary>
    //TMXImporter importer;

    private Transform rootTransform;

    /// <summary>
    /// Runs map-building logic
    /// </summary>
    public void RerunBuilder(Transform rootTransform, string assetPath)
    {
        this.rootTransform = rootTransform;
        Vector3 currentScale = this.rootTransform.localScale;
        this.rootTransform.localScale = Vector3.one;
        mappings = new List<SpriteToModel>();
        modelsAtlases = new List<Transform>();

        foreach(GameObject obj in Resources.LoadAll<GameObject>(TileCreator.ATLASES_FOLDER)){
            if(obj.GetComponent<TileCreator>() != null){
                modelsAtlases.Add(obj.transform);
            }
        }

        if(modelsAtlases.Count == 0){
            Debug.LogWarning("No 3D tile atlases were found. 3D model cannot be generated.");
        }

        System.GC.Collect();

        RebuildModels();
        SetLayersHeights();
        this.rootTransform.localScale = currentScale;
    }

    /// <summary>
    /// Reads updated map data from tmx file through TMXImporter and rebuilds
    /// the scene using the data from the new map. Any objects that were modified
    /// in the editor are kept without changing
    /// </summary>
    private void RebuildModels()
    {
        for (int i = 0; i < rootTransform.childCount; i++)
        {
            Transform layer = rootTransform.GetChild(i);

            List<GameObject> models = new List<GameObject>();
            while (layer.childCount > 0)
            {
                for (int j = 0; j < layer.childCount; j++)
                {
                    Transform child = layer.GetChild(j);
                    SpriteRenderer sr = child.GetComponent<SpriteRenderer>();
                    SpriteToModel mapping = GetMapping(sr.sprite);

                    if (mapping == null)
                    {
                        mapping = new SpriteToModel();
                        int firstDashIndex = sr.sprite.name.IndexOf('-');
                        string spriteName = sr.sprite.name.Substring(firstDashIndex + 1);
                        string modelName = spriteName.Substring(0, spriteName.Length - 4);

                        for (int a = 0; a < modelsAtlases.Count; a++)
                        {
                            for (int k = 0; k < modelsAtlases[a].childCount; k++)
                            {
                                if (modelsAtlases[a].GetChild(k).name.Equals(modelName))
                                {
                                    mapping.model = modelsAtlases[a].GetChild(k).gameObject;
                                    break;
                                }
                            }
                        }

                        if (mapping.model == null)
                        {
                            mapping = null;
                        }
                        else
                        {
                            mapping.sprite = sr.sprite;
                            mapping.modelRotation = float.Parse(
                                                        spriteName.Substring(spriteName.LastIndexOf('_') + 1, 3));

                            mappings.Add(mapping);
                        }
                    }

                    if (mapping != null)
                    {
                        Vector3 pos = new Vector3(child.position.x, 0.0f, child.position.y);

                        GameObject model = null;

                        if (model == null)
                        {
                            model = (GameObject)GameObject.Instantiate(mapping.model);
                            model.name = mapping.sprite.name + ":" + layer.name + ":" + child.name;

                            model.isStatic = true;
                            model.transform.position = pos;

                            model.transform.localScale = tileScale;

                            model.transform.Rotate(0, mapping.modelRotation, 0);
                            Tile3D tileScript = model.GetComponent<Tile3D>();
                            if(tileScript.generateCollider){
                                model.AddComponent<MeshCollider>();
                            }
                            ProcessRandomModifications(tileScript);

                            //TODO: needs fixing
                            // if(sr.transform.eulerAngles.z != 0)
                            // {
                            //     model.transform.Rotate(0, sr.transform.eulerAngles.z, 0);
                            //     Vector3 scale = model.transform.localScale;
                            //     scale.z *= -1;
                            //     model.transform.localScale = scale;
                            // }

                            // model.transform.localScale = new Vector3(
                            //    model.transform.localScale.x * (sr.flipX ? -1 : 1),
                            //    model.transform.localScale.y,
                            //    model.transform.localScale.z * (sr.flipY ? -1 : 1)
                            //    );

                        }

                        models.Add(model);

                    } else {
                        Debug.LogWarning("No 3D mapping found for '" + sr.sprite.name + "'. Cannot build 3D tile");
                    }
                    GameObject.DestroyImmediate(child.gameObject);
                }
            }

            foreach (GameObject model in models)
            {
                model.transform.parent = layer;
            }
        }
    }

    /// <summary>
    /// Reads properties stored in a Tile3D script and modifies
    /// the tile using the provided ranges of random modifications
    /// </summary>
    /// <param name="tile">Script to read randomization data from</param>
    private void ProcessRandomModifications(Tile3D tile)
    {
        if (tile.maxRandomCopies > 0 ||
            tile.randomRotationSnapAngle != 0.0f ||
            tile.maxRandomDisplacement != Vector3.zero ||
            tile.maxRandomScale != 0.0f)
        {

            GameObject midParent = new GameObject("Copy0");
            midParent.transform.parent = tile.transform;
            midParent.transform.position = tile.transform.position;

            while (tile.transform.childCount > 1)
            {
                Transform originalChild = tile.transform.GetChild(0);
                if (originalChild == midParent.transform)
                {
                    originalChild = tile.transform.GetChild(1);
                }

                originalChild.transform.parent = midParent.transform;
            }

            for (int i = 0; i < tile.maxRandomCopies; i++)
            {
                GameObject newCopy = (GameObject)GameObject.Instantiate(midParent);
                newCopy.name = "Copy" + (i + 1);
                newCopy.transform.parent = tile.transform;
                newCopy.transform.position = midParent.transform.position;
                newCopy.transform.localScale = midParent.transform.localScale;
            }

            for (int i = 0; i < tile.maxRandomCopies + 1; i++)
            {
                Transform child = tile.transform.GetChild(i);

                float scaleFactor = Mathf.Clamp01(tile.maxRandomScale);

                float randomScale = Random.Range(-scaleFactor * 0.5f, scaleFactor * 0.5f);
                child.localScale += child.localScale * randomScale;

                if (tile.randomRotationSnapAngle > 0.0f)
                {
                    //for(int j = 0; j < child.childCount; j++){
                    int snap = Mathf.RoundToInt(tile.randomRotationSnapAngle * 0.5f);
                    if (snap == 0) snap = 1;
                    int ang = Random.Range(0, 360);

                    while (ang % snap != 0)
                    {
                        ang++;
                    }

                    int negative = Random.Range(0, 2);
                    if (negative != 0)
                    {
                        ang *= -1;
                    }

                    child.Rotate(0.0f, ang, 0.0f);
                    //}
                }

                float minX, minY, minZ, maxX, maxY, maxZ;

                minX = Random.Range(-tile.minRandomDisplacement.x, tile.minRandomDisplacement.x);
                if (minX >= 0.0f)
                {
                    maxX = Random.Range(tile.minRandomDisplacement.x, tile.maxRandomDisplacement.x);
                }
                else
                {
                    maxX = Random.Range(-tile.maxRandomDisplacement.x, -tile.minRandomDisplacement.x);
                }

                minY = Random.Range(-tile.minRandomDisplacement.y, tile.minRandomDisplacement.y);
                if (minY >= 0.0f)
                {
                    maxY = Random.Range(tile.minRandomDisplacement.y, tile.maxRandomDisplacement.y);
                }
                else
                {
                    maxY = Random.Range(-tile.maxRandomDisplacement.y, -tile.minRandomDisplacement.y);
                }

                minZ = Random.Range(-tile.minRandomDisplacement.z, tile.minRandomDisplacement.z);
                if (minZ >= 0.0f)
                {
                    maxZ = Random.Range(tile.minRandomDisplacement.z, tile.maxRandomDisplacement.z);
                }
                else
                {
                    maxZ = Random.Range(-tile.maxRandomDisplacement.z, -tile.minRandomDisplacement.z);
                }

                child.Translate(
                    Random.Range(Mathf.Min(minX, maxX), Mathf.Max(minX, maxX)),
                    Random.Range(Mathf.Min(minY, maxY), Mathf.Max(minY, maxY)),
                    Random.Range(Mathf.Min(minZ, maxZ), Mathf.Max(minZ, maxZ)));
            }

            List<GameObject> toDestroy = new List<GameObject>();

            for (int i = 0; i < tile.maxRandomCopies + 1; i++)
            {
                Transform child = tile.transform.GetChild(i);
                for (int j = 0; j < tile.maxRandomCopies + 1; j++)
                {
                    Transform other = tile.transform.GetChild(j);

                    if (other != child &&
                        Vector3.Distance(other.position, child.position) < tile.minRandomDisplacement.magnitude)
                    {
                        if (!toDestroy.Contains(other.gameObject) && toDestroy.Count < tile.maxRandomCopies)
                        {
                            toDestroy.Add(other.gameObject);
                        }
                    }
                }
            }

            for (int i = 0; i < toDestroy.Count; i++)
            {
                GameObject.DestroyImmediate(toDestroy[i]);
            }
        }
    }

    /// <summary>
    /// Gets the SpriteToModel mapping of the provided Sprite
    /// </summary>
    /// <returns>The mapping if exists, null otherwise</returns>
    /// <param name="sp">Sprite to get mapping for</param>
    private SpriteToModel GetMapping(Sprite sp)
    {
        foreach (SpriteToModel mapping in mappings)
        {
            if (mapping.sprite == sp)
            {
                return mapping;
            }
        }
        return null;
    }

    /// <summary>
    /// Sets the heights of the layers and models in them based on specified
    /// constant heights or by stacking objects over one another
    /// </summary>
    private void SetLayersHeights()
    {

        int groundLayerIndex = rootTransform.childCount - 1;
        for (int i = 0; i < rootTransform.childCount; i++)
        {
            if (rootTransform.GetChild(i).name.Equals(
                        "Ground", System.StringComparison.OrdinalIgnoreCase))
            {
                groundLayerIndex = i;
                break;
            }
        }

        //Start from ground layer down
        for (int i = groundLayerIndex + 1; i < rootTransform.childCount; i++)
        {
            Transform child = rootTransform.GetChild(i);

            bool adjustToUpperLayer = true;
            LayerCustomProperties properties = child.GetComponent<LayerCustomProperties>();
            if (properties != null && properties.height != float.MinValue)
            {
                Vector3 pos = child.position;
                pos.y = properties.height;
                child.position = pos;
                adjustToUpperLayer = false;
            }

            for (int t = 0; t < child.childCount; t++)
            {
                Transform myTile = child.GetChild(t);

                if (adjustToUpperLayer)
                {
                    float minPos = float.MaxValue;
                    int firstDashIndex = myTile.name.IndexOf('-');
                    float myHeight = float.Parse(myTile.name.Substring(0, firstDashIndex));
                    //myHeight *= transform.localScale.y;

                    //Search in upper layers only
                    for (int j = i - 1; j >= 0; j--)
                    {

                        Transform layer = rootTransform.GetChild(j);
                        for (int k = 0; k < layer.childCount; k++)
                        {
                            Transform otherTile = layer.GetChild(k);

                            float pos = otherTile.position.y - myHeight;
                            if (pos < minPos)
                            {
                                minPos = pos;
                            }
                        }
                    }

                    Vector3 newPos = myTile.position;
                    newPos.y = minPos;
                    myTile.position = newPos;
                }
            }
        }

        //Start from ground layer up
        for (int i = groundLayerIndex - 1; i >= 0; i--)
        {
            Transform child = rootTransform.GetChild(i);

            bool adjustToLoewrLayer = true;
            LayerCustomProperties properties = child.GetComponent<LayerCustomProperties>();
            if (properties != null && properties.height != float.MinValue)
            {
                Vector3 pos = child.position;
                pos.y = properties.height;
                child.position = pos;
                adjustToLoewrLayer = false;
            }

            for (int t = 0; t < child.childCount; t++)
            {
                Transform myTile = child.GetChild(t);

                if (adjustToLoewrLayer)
                {
                    float maxHeight = 0.0f;
                    //Search in lower layers only
                    for (int j = i + 1; j < rootTransform.childCount; j++)
                    {

                        Transform layer = rootTransform.GetChild(j);
                        for (int k = 0; k < layer.childCount; k++)
                        {
                            Transform otherTile = layer.GetChild(k);
                            if (myTile.position.x == otherTile.position.x &&
                                myTile.position.z == otherTile.position.z)
                            {

                                Collider col = otherTile.GetComponentInChildren<Collider>();
                                if (col != null)
                                {
                                    int firstDashIndex = otherTile.name.IndexOf('-');
                                    float height = float.Parse(otherTile.name.Substring(0, firstDashIndex));
                                    height *= myTile.localScale.y;
                                    height += otherTile.position.y;
                                    if (height > maxHeight)
                                    {
                                        maxHeight = height;

                                    }
                                }
                            }
                        }
                    }

                    myTile.Translate(0, maxHeight, 0, Space.World);
                }
            }
        }
    }
}

/// <summary>
/// Maps a sprite to a 3D model game object
/// </summary>
[System.Serializable]
public class SpriteToModel
{
    /// <summary>
    /// The sprite.
    /// </summary>
    public Sprite sprite;
    /// <summary>
    /// The model.
    /// </summary>
    public GameObject model;
    /// <summary>
    /// The model rotation.
    /// </summary>
    public float modelRotation;

    public string uniqueName;
}
#endif